import { Injectable, inject, NgZone } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { Observable, Subject, take, merge, finalize, fromEvent, switchMap, takeUntil, takeWhile } from 'rxjs';
import BezierEasing from './bezier-easing';
import { SMOOTH_SCROLL_OPTIONS } from './smooth-scroll.model';
import * as i0 from "@angular/core";
export class SmoothScrollManager {
    constructor() {
        this.document = inject(DOCUMENT);
        this.zone = inject(NgZone);
        // Default options
        this._defaultOptions = {
            duration: 468,
            easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            },
            ...inject(SMOOTH_SCROLL_OPTIONS, { optional: true }),
        };
        // Keeps track of the ongoing SmoothScroll functions, so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this.onGoingScrolls = new Map();
    }
    /**
     * Timing method
     */
    get now() {
        return this.document.defaultView.performance?.now?.bind(this.document.defaultView.performance) || Date.now;
    }
    /**
     * changes scroll position inside an element
     */
    scrollElement(el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    }
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    getElement(el, parent) {
        if (typeof el === 'string') {
            return (parent || this.document).querySelector(el);
        }
        return coerceElement(el);
    }
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    getScrollDestroyerRef(el) {
        if (this.onGoingScrolls.has(el)) {
            this.onGoingScrolls.get(el).next();
        }
        return this.onGoingScrolls.set(el, new Subject()).get(el);
    }
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    step(context) {
        return new Observable((subscriber) => {
            let elapsed = (this.now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            const value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            this.scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            requestAnimationFrame(() => {
                subscriber.next();
                subscriber.complete();
            });
        });
    }
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream
     */
    isReached(context, destroyed) {
        if (context.currentX === context.x && context.currentY === context.y) {
            // IMPORTANT: Destroy the stream when scroll is reached ASAP!
            destroyed.next();
            return true;
        }
        return false;
    }
    /**
     * Scroll recursively until coordinates are reached
     * @param context
     * @param destroyed
     */
    scrolling(context, destroyed) {
        return this.step(context).pipe(
        // Continue while target coordinates hasn't reached yet
        takeWhile(() => !this.isReached(context, destroyed)), switchMap(() => this.scrolling(context, destroyed)));
    }
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    onScrollReached(el, resolve, destroyed) {
        destroyed.complete();
        this.onGoingScrolls.delete(el);
        this.zone.run(() => resolve());
    }
    /**
     * Terminates an ongoing smooth scroll
     */
    interrupted(el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    }
    applyScrollToOptions(el, options) {
        if (!options.duration) {
            this.scrollElement(el, options.left, options.top);
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            this.zone.runOutsideAngular(() => {
                // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
                const destroyed = this.getScrollDestroyerRef(el);
                const context = {
                    scrollable: el,
                    startTime: this.now(),
                    startX: el.scrollLeft,
                    startY: el.scrollTop,
                    x: options.left == null ? el.scrollLeft : ~~options.left,
                    y: options.top == null ? el.scrollTop : ~~options.top,
                    duration: options.duration,
                    easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
                };
                this.scrolling(context, destroyed).pipe(
                // Continue until interrupted by another scroll (new smooth scroll / wheel / touchmove)
                takeUntil(this.interrupted(el, destroyed)), 
                // Once finished, clean up the destroyer stream and resolve the promise
                finalize(() => this.onScrollReached(el, resolve, destroyed))).subscribe();
            });
        });
    }
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param customOptions specified the offsets to scroll to.
     */
    scrollTo(scrollable, customOptions) {
        const el = this.getElement(scrollable);
        const isRtl = getComputedStyle(el).direction === 'rtl';
        const options = {
            ...this._defaultOptions,
            ...customOptions,
            ...{
                // Rewrite start & end offsets as right or left offsets.
                left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,
                right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right
            }
        };
        // Rewrite the bottom offset as a top offset.
        if (options.bottom != null) {
            options.top = el.scrollHeight - el.clientHeight - options.bottom;
        }
        // Rewrite the right offset as a left offset.
        if (isRtl) {
            if (options.left != null) {
                options.right = el.scrollWidth - el.clientWidth - options.left;
            }
            options.left = options.right ? -options.right : options.right;
        }
        else {
            if (options.right != null) {
                options.left = el.scrollWidth - el.clientWidth - options.right;
            }
        }
        return this.applyScrollToOptions(el, options);
    }
    /**
     * Scroll to element by reference or selector
     */
    scrollToElement(scrollable, target, customOptions = {}) {
        const scrollableEl = this.getElement(scrollable);
        const targetEl = this.getElement(target, scrollableEl);
        if (targetEl && scrollableEl) {
            const scrollableRect = scrollableEl.getBoundingClientRect();
            const targetRect = targetEl.getBoundingClientRect();
            const options = {
                ...customOptions,
                left: targetRect.left + scrollableEl.scrollLeft - scrollableRect.left + (customOptions.left || 0),
                top: targetRect.top + scrollableEl.scrollTop - scrollableRect.top + (customOptions.top || 0)
            };
            return this.scrollTo(scrollableEl, options);
        }
        return Promise.resolve();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: SmoothScrollManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: SmoothScrollManager, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: SmoothScrollManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXNjcm9sbGJhci9zbW9vdGgtc2Nyb2xsL3NyYy9zbW9vdGgtc2Nyb2xsLW1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQWMsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFdEQsT0FBTyxFQUNMLFVBQVUsRUFFVixPQUFPLEVBQ1AsSUFBSSxFQUNKLEtBQUssRUFDTCxRQUFRLEVBQ1IsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNWLE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxZQUFZLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUNMLHFCQUFxQixFQUt0QixNQUFNLHVCQUF1QixDQUFDOztBQUsvQixNQUFNLE9BQU8sbUJBQW1CO0lBSGhDO1FBS1UsYUFBUSxHQUFhLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUV0QyxTQUFJLEdBQVcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXRDLGtCQUFrQjtRQUNELG9CQUFlLEdBQTBCO1lBQ3hELFFBQVEsRUFBRSxHQUFHO1lBQ2IsTUFBTSxFQUFFO2dCQUNOLEVBQUUsRUFBRSxJQUFJO2dCQUNSLEVBQUUsRUFBRSxDQUFDO2dCQUNMLEVBQUUsRUFBRSxJQUFJO2dCQUNSLEVBQUUsRUFBRSxDQUFDO2FBQ047WUFDRCxHQUFHLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQztTQUNyRCxDQUFDO1FBRUYsb0dBQW9HO1FBQ3BHLG1HQUFtRztRQUNuRyxvR0FBb0c7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RSxDQUFDO1lBQ3JFLE1BQU0sVUFBVSxHQUFZLFFBQVEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1lBRTdELE1BQU0sT0FBTyxHQUEwQjtnQkFDckMsR0FBRyxhQUFhO2dCQUNoQixJQUFJLEVBQUUsVUFBVSxDQUFDLElBQUksR0FBRyxZQUFZLENBQUMsVUFBVSxHQUFHLGNBQWMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxhQUFhLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQztnQkFDakcsR0FBRyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEdBQUcsWUFBWSxDQUFDLFNBQVMsR0FBRyxjQUFjLENBQUMsR0FBRyxHQUFHLENBQUMsYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7YUFDN0YsQ0FBQztZQUVGLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDN0M7UUFFRCxPQUFPLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUMzQixDQUFDOzhHQWhPVSxtQkFBbUI7a0hBQW5CLG1CQUFtQixjQUZsQixNQUFNOzsyRkFFUCxtQkFBbUI7a0JBSC9CLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgaW5qZWN0LCBFbGVtZW50UmVmLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBjb2VyY2VFbGVtZW50IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcclxuaW1wb3J0IHsgX1dpdGhvdXQsIF9ZQXhpcyB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zY3JvbGxpbmcnO1xyXG5pbXBvcnQge1xyXG4gIE9ic2VydmFibGUsXHJcbiAgU3Vic2NyaWJlcixcclxuICBTdWJqZWN0LFxyXG4gIHRha2UsXHJcbiAgbWVyZ2UsXHJcbiAgZmluYWxpemUsXHJcbiAgZnJvbUV2ZW50LFxyXG4gIHN3aXRjaE1hcCxcclxuICB0YWtlVW50aWwsXHJcbiAgdGFrZVdoaWxlXHJcbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCBCZXppZXJFYXNpbmcgZnJvbSAnLi9iZXppZXItZWFzaW5nJztcclxuaW1wb3J0IHtcclxuICBTTU9PVEhfU0NST0xMX09QVElPTlMsXHJcbiAgU21vb3RoU2Nyb2xsRWxlbWVudCxcclxuICBTbW9vdGhTY3JvbGxTdGVwLFxyXG4gIFNtb290aFNjcm9sbFRvRWxlbWVudE9wdGlvbnMsXHJcbiAgU21vb3RoU2Nyb2xsVG9PcHRpb25zXHJcbn0gZnJvbSAnLi9zbW9vdGgtc2Nyb2xsLm1vZGVsJztcclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIFNtb290aFNjcm9sbE1hbmFnZXIge1xyXG5cclxuICBwcml2YXRlIGRvY3VtZW50OiBEb2N1bWVudCA9IGluamVjdChET0NVTUVOVCk7XHJcblxyXG4gIHByaXZhdGUgem9uZTogTmdab25lID0gaW5qZWN0KE5nWm9uZSk7XHJcblxyXG4gIC8vIERlZmF1bHQgb3B0aW9uc1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2RlZmF1bHRPcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMgPSB7XHJcbiAgICBkdXJhdGlvbjogNDY4LFxyXG4gICAgZWFzaW5nOiB7XHJcbiAgICAgIHgxOiAwLjQyLFxyXG4gICAgICB5MTogMCxcclxuICAgICAgeDI6IDAuNTgsXHJcbiAgICAgIHkyOiAxXHJcbiAgICB9LFxyXG4gICAgLi4uaW5qZWN0KFNNT09USF9TQ1JPTExfT1BUSU9OUywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcclxuICB9O1xyXG5cclxuICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgb25nb2luZyBTbW9vdGhTY3JvbGwgZnVuY3Rpb25zLCBzbyB0aGV5IGNhbiBiZSBoYW5kbGVkIGluIGNhc2Ugb2YgZHVwbGljYXRpb24uXHJcbiAgLy8gRWFjaCBzY3JvbGxlZCBlbGVtZW50IGdldHMgYSBkZXN0cm95ZXIgc3RyZWFtIHdoaWNoIGdldHMgZGVsZXRlZCBpbW1lZGlhdGVseSBhZnRlciBpdCBjb21wbGV0ZXMuXHJcbiAgLy8gUHVycG9zZTogSWYgdXNlciBjYWxsZWQgYSBzY3JvbGwgZnVuY3Rpb24gYWdhaW4gb24gdGhlIHNhbWUgZWxlbWVudCBiZWZvcmUgdGhlIHNjcm9sbHMgY29tcGxldGVzLFxyXG4gIC8vIGl0IGNhbmNlbHMgdGhlIG9uZ29pbmcgc2Nyb2xsIGFuZCBzdGFydHMgYSBuZXcgb25lXHJcbiAgcHJpdmF0ZSBvbkdvaW5nU2Nyb2xsczogTWFwPEVsZW1lbnQsIFN1YmplY3Q8dm9pZD4+ID0gbmV3IE1hcDxFbGVtZW50LCBTdWJqZWN0PHZvaWQ+PigpO1xyXG5cclxuICAvKipcclxuICAgKiBUaW1pbmcgbWV0aG9kXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXQgbm93KCk6ICgpID0+IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5kZWZhdWx0Vmlldy5wZXJmb3JtYW5jZT8ubm93Py5iaW5kKHRoaXMuZG9jdW1lbnQuZGVmYXVsdFZpZXcucGVyZm9ybWFuY2UpIHx8IERhdGUubm93O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogY2hhbmdlcyBzY3JvbGwgcG9zaXRpb24gaW5zaWRlIGFuIGVsZW1lbnRcclxuICAgKi9cclxuICBwcml2YXRlIHNjcm9sbEVsZW1lbnQoZWw6IEVsZW1lbnQsIHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBlbC5zY3JvbGxMZWZ0ID0geDtcclxuICAgIGVsLnNjcm9sbFRvcCA9IHk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGEgZ2l2ZW4gcGFyYW1ldGVyIG9mIHR5cGUgSFRNTEVsZW1lbnQsIEVsZW1lbnRSZWYgb3Igc2VsZWN0b3JcclxuICAgKi9cclxuICBwcml2YXRlIGdldEVsZW1lbnQoZWw6IEVsZW1lbnQgfCBFbGVtZW50UmVmIHwgc3RyaW5nLCBwYXJlbnQ/OiBFbGVtZW50KTogRWxlbWVudCB7XHJcbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gKHBhcmVudCB8fCB0aGlzLmRvY3VtZW50KS5xdWVyeVNlbGVjdG9yKGVsKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2VyY2VFbGVtZW50PEVsZW1lbnQ+KGVsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIGEgZGVzdHJveWVyIHN0cmVhbSwgcmUtaW5pdGlhbGl6ZXMgaXQgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBzY3JvbGxlZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0U2Nyb2xsRGVzdHJveWVyUmVmKGVsOiBFbGVtZW50KTogU3ViamVjdDx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5vbkdvaW5nU2Nyb2xscy5oYXMoZWwpKSB7XHJcbiAgICAgIHRoaXMub25Hb2luZ1Njcm9sbHMuZ2V0KGVsKS5uZXh0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5vbkdvaW5nU2Nyb2xscy5zZXQoZWwsIG5ldyBTdWJqZWN0PHZvaWQ+KCkpLmdldChlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIGZ1bmN0aW9uIGNhbGxlZCByZWN1cnNpdmVseSB0aGF0LCBnaXZlbiBhIGNvbnRleHQsIHN0ZXBzIHRocm91Z2ggc2Nyb2xsaW5nXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGVwKGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXApOiBPYnNlcnZhYmxlPHZvaWQ+IHtcclxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjx2b2lkPikgPT4ge1xyXG4gICAgICBsZXQgZWxhcHNlZDogbnVtYmVyID0gKHRoaXMubm93KCkgLSBjb250ZXh0LnN0YXJ0VGltZSkgLyBjb250ZXh0LmR1cmF0aW9uO1xyXG5cclxuICAgICAgLy8gYXZvaWQgZWxhcHNlZCB0aW1lcyBoaWdoZXIgdGhhbiBvbmVcclxuICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XHJcblxyXG4gICAgICAvLyBhcHBseSBlYXNpbmcgdG8gZWxhcHNlZCB0aW1lXHJcbiAgICAgIGNvbnN0IHZhbHVlOiBudW1iZXIgPSBjb250ZXh0LmVhc2luZyhlbGFwc2VkKTtcclxuXHJcbiAgICAgIGNvbnRleHQuY3VycmVudFggPSBjb250ZXh0LnN0YXJ0WCArIChjb250ZXh0LnggLSBjb250ZXh0LnN0YXJ0WCkgKiB2YWx1ZTtcclxuICAgICAgY29udGV4dC5jdXJyZW50WSA9IGNvbnRleHQuc3RhcnRZICsgKGNvbnRleHQueSAtIGNvbnRleHQuc3RhcnRZKSAqIHZhbHVlO1xyXG5cclxuICAgICAgdGhpcy5zY3JvbGxFbGVtZW50KGNvbnRleHQuc2Nyb2xsYWJsZSwgY29udGV4dC5jdXJyZW50WCwgY29udGV4dC5jdXJyZW50WSk7XHJcbiAgICAgIC8vIFByb2NlZWQgdG8gdGhlIHN0ZXBcclxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICBzdWJzY3JpYmVyLm5leHQoKTtcclxuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgc21vb3RoIHNjcm9sbCBoYXMgcmVhY2hlZCwgY2xlYW5zIHVwIHRoZSBzbW9vdGggc2Nyb2xsIHN0cmVhbVxyXG4gICAqL1xyXG4gIHByaXZhdGUgaXNSZWFjaGVkKGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXAsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPik6IGJvb2xlYW4ge1xyXG4gICAgaWYgKGNvbnRleHQuY3VycmVudFggPT09IGNvbnRleHQueCAmJiBjb250ZXh0LmN1cnJlbnRZID09PSBjb250ZXh0LnkpIHtcclxuICAgICAgLy8gSU1QT1JUQU5UOiBEZXN0cm95IHRoZSBzdHJlYW0gd2hlbiBzY3JvbGwgaXMgcmVhY2hlZCBBU0FQIVxyXG4gICAgICBkZXN0cm95ZWQubmV4dCgpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbCByZWN1cnNpdmVseSB1bnRpbCBjb29yZGluYXRlcyBhcmUgcmVhY2hlZFxyXG4gICAqIEBwYXJhbSBjb250ZXh0XHJcbiAgICogQHBhcmFtIGRlc3Ryb3llZFxyXG4gICAqL1xyXG4gIHNjcm9sbGluZyhjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwLCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4pOiBPYnNlcnZhYmxlPHZvaWQ+IHtcclxuICAgIHJldHVybiB0aGlzLnN0ZXAoY29udGV4dCkucGlwZShcclxuICAgICAgLy8gQ29udGludWUgd2hpbGUgdGFyZ2V0IGNvb3JkaW5hdGVzIGhhc24ndCByZWFjaGVkIHlldFxyXG4gICAgICB0YWtlV2hpbGUoKCkgPT4gIXRoaXMuaXNSZWFjaGVkKGNvbnRleHQsIGRlc3Ryb3llZCkpLFxyXG4gICAgICBzd2l0Y2hNYXAoKCkgPT4gdGhpcy5zY3JvbGxpbmcoY29udGV4dCwgZGVzdHJveWVkKSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGVzIHRoZSBkZXN0cm95ZXIgZnVuY3Rpb24sIHJ1bnMgaWYgdGhlIHNtb290aCBzY3JvbGwgaGFzIGZpbmlzaGVkIG9yIGludGVycnVwdGVkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBvblNjcm9sbFJlYWNoZWQoZWw6IEVsZW1lbnQsIHJlc29sdmU6ICgpID0+IHZvaWQsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPik6IHZvaWQge1xyXG4gICAgZGVzdHJveWVkLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLm9uR29pbmdTY3JvbGxzLmRlbGV0ZShlbCk7XHJcbiAgICB0aGlzLnpvbmUucnVuKCgpID0+IHJlc29sdmUoKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXJtaW5hdGVzIGFuIG9uZ29pbmcgc21vb3RoIHNjcm9sbFxyXG4gICAqL1xyXG4gIHByaXZhdGUgaW50ZXJydXB0ZWQoZWw6IEVsZW1lbnQsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPik6IE9ic2VydmFibGU8RXZlbnQgfCB2b2lkPiB7XHJcbiAgICByZXR1cm4gbWVyZ2UoXHJcbiAgICAgIGZyb21FdmVudChlbCwgJ3doZWVsJywgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pLFxyXG4gICAgICBmcm9tRXZlbnQoZWwsICd0b3VjaG1vdmUnLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSksXHJcbiAgICAgIGRlc3Ryb3llZFxyXG4gICAgKS5waXBlKHRha2UoMSkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhcHBseVNjcm9sbFRvT3B0aW9ucyhlbDogRWxlbWVudCwgb3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIW9wdGlvbnMuZHVyYXRpb24pIHtcclxuICAgICAgdGhpcy5zY3JvbGxFbGVtZW50KGVsLCBvcHRpb25zLmxlZnQsIG9wdGlvbnMudG9wKTtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgYSBkZXN0cm95ZXIgc3RyZWFtLCByZWluaXRpYWxpemUgaXQgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBzY3JvbGxlZFxyXG4gICAgICAgIGNvbnN0IGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPiA9IHRoaXMuZ2V0U2Nyb2xsRGVzdHJveWVyUmVmKGVsKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCA9IHtcclxuICAgICAgICAgIHNjcm9sbGFibGU6IGVsLFxyXG4gICAgICAgICAgc3RhcnRUaW1lOiB0aGlzLm5vdygpLFxyXG4gICAgICAgICAgc3RhcnRYOiBlbC5zY3JvbGxMZWZ0LFxyXG4gICAgICAgICAgc3RhcnRZOiBlbC5zY3JvbGxUb3AsXHJcbiAgICAgICAgICB4OiBvcHRpb25zLmxlZnQgPT0gbnVsbCA/IGVsLnNjcm9sbExlZnQgOiB+fm9wdGlvbnMubGVmdCxcclxuICAgICAgICAgIHk6IG9wdGlvbnMudG9wID09IG51bGwgPyBlbC5zY3JvbGxUb3AgOiB+fm9wdGlvbnMudG9wLFxyXG4gICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXHJcbiAgICAgICAgICBlYXNpbmc6IEJlemllckVhc2luZyhvcHRpb25zLmVhc2luZy54MSwgb3B0aW9ucy5lYXNpbmcueTEsIG9wdGlvbnMuZWFzaW5nLngyLCBvcHRpb25zLmVhc2luZy55MilcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLnNjcm9sbGluZyhjb250ZXh0LCBkZXN0cm95ZWQpLnBpcGUoXHJcbiAgICAgICAgICAvLyBDb250aW51ZSB1bnRpbCBpbnRlcnJ1cHRlZCBieSBhbm90aGVyIHNjcm9sbCAobmV3IHNtb290aCBzY3JvbGwgLyB3aGVlbCAvIHRvdWNobW92ZSlcclxuICAgICAgICAgIHRha2VVbnRpbCh0aGlzLmludGVycnVwdGVkKGVsLCBkZXN0cm95ZWQpKSxcclxuICAgICAgICAgIC8vIE9uY2UgZmluaXNoZWQsIGNsZWFuIHVwIHRoZSBkZXN0cm95ZXIgc3RyZWFtIGFuZCByZXNvbHZlIHRoZSBwcm9taXNlXHJcbiAgICAgICAgICBmaW5hbGl6ZSgoKSA9PiB0aGlzLm9uU2Nyb2xsUmVhY2hlZChlbCwgcmVzb2x2ZSwgZGVzdHJveWVkKSksXHJcbiAgICAgICAgKS5zdWJzY3JpYmUoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCBvZmZzZXRzLiBUaGlzIGlzIGEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBicm93c2VyJ3MgbmF0aXZlIHNjcm9sbFRvXHJcbiAgICogbWV0aG9kLCBzaW5jZSBicm93c2VycyBhcmUgbm90IGNvbnNpc3RlbnQgYWJvdXQgd2hhdCBzY3JvbGxMZWZ0IG1lYW5zIGluIFJUTC4gRm9yIHRoaXMgbWV0aG9kXHJcbiAgICogbGVmdCBhbmQgcmlnaHQgYWx3YXlzIHJlZmVyIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSBzY3JvbGxpbmcgY29udGFpbmVyIGlycmVzcGVjdGl2ZVxyXG4gICAqIG9mIHRoZSBsYXlvdXQgZGlyZWN0aW9uLiBzdGFydCBhbmQgZW5kIHJlZmVyIHRvIGxlZnQgYW5kIHJpZ2h0IGluIGFuIExUUiBjb250ZXh0IGFuZCB2aWNlLXZlcnNhXHJcbiAgICogaW4gYW4gUlRMIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHNjcm9sbGFibGUgZWxlbWVudFxyXG4gICAqIEBwYXJhbSBjdXN0b21PcHRpb25zIHNwZWNpZmllZCB0aGUgb2Zmc2V0cyB0byBzY3JvbGwgdG8uXHJcbiAgICovXHJcbiAgc2Nyb2xsVG8oc2Nyb2xsYWJsZTogU21vb3RoU2Nyb2xsRWxlbWVudCwgY3VzdG9tT3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBlbDogRWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudChzY3JvbGxhYmxlKTtcclxuICAgIGNvbnN0IGlzUnRsOiBib29sZWFuID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZGlyZWN0aW9uID09PSAncnRsJztcclxuXHJcbiAgICBjb25zdCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMgPSB7XHJcbiAgICAgIC4uLih0aGlzLl9kZWZhdWx0T3B0aW9ucyBhcyBfV2l0aG91dDxfWUF4aXM+KSxcclxuICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcclxuICAgICAgLi4uKHtcclxuICAgICAgICAvLyBSZXdyaXRlIHN0YXJ0ICYgZW5kIG9mZnNldHMgYXMgcmlnaHQgb3IgbGVmdCBvZmZzZXRzLlxyXG4gICAgICAgIGxlZnQ6IGN1c3RvbU9wdGlvbnMubGVmdCA9PSBudWxsID8gKGlzUnRsID8gY3VzdG9tT3B0aW9ucy5lbmQgOiBjdXN0b21PcHRpb25zLnN0YXJ0KSA6IGN1c3RvbU9wdGlvbnMubGVmdCxcclxuICAgICAgICByaWdodDogY3VzdG9tT3B0aW9ucy5yaWdodCA9PSBudWxsID8gKGlzUnRsID8gY3VzdG9tT3B0aW9ucy5zdGFydCA6IGN1c3RvbU9wdGlvbnMuZW5kKSA6IGN1c3RvbU9wdGlvbnMucmlnaHRcclxuICAgICAgfSBhcyBfV2l0aG91dDxfWUF4aXM+KVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSZXdyaXRlIHRoZSBib3R0b20gb2Zmc2V0IGFzIGEgdG9wIG9mZnNldC5cclxuICAgIGlmIChvcHRpb25zLmJvdHRvbSAhPSBudWxsKSB7XHJcbiAgICAgIG9wdGlvbnMudG9wID0gZWwuc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0IC0gb3B0aW9ucy5ib3R0b207XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV3cml0ZSB0aGUgcmlnaHQgb2Zmc2V0IGFzIGEgbGVmdCBvZmZzZXQuXHJcbiAgICBpZiAoaXNSdGwpIHtcclxuICAgICAgaWYgKG9wdGlvbnMubGVmdCAhPSBudWxsKSB7XHJcbiAgICAgICAgb3B0aW9ucy5yaWdodCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGggLSBvcHRpb25zLmxlZnQ7XHJcbiAgICAgIH1cclxuICAgICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5yaWdodCA/IC1vcHRpb25zLnJpZ2h0IDogb3B0aW9ucy5yaWdodDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChvcHRpb25zLnJpZ2h0ICE9IG51bGwpIHtcclxuICAgICAgICBvcHRpb25zLmxlZnQgPSBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoIC0gb3B0aW9ucy5yaWdodDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTY3JvbGxUb09wdGlvbnMoZWwsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIHRvIGVsZW1lbnQgYnkgcmVmZXJlbmNlIG9yIHNlbGVjdG9yXHJcbiAgICovXHJcbiAgc2Nyb2xsVG9FbGVtZW50KHNjcm9sbGFibGU6IFNtb290aFNjcm9sbEVsZW1lbnQsIHRhcmdldDogU21vb3RoU2Nyb2xsRWxlbWVudCwgY3VzdG9tT3B0aW9uczogU21vb3RoU2Nyb2xsVG9FbGVtZW50T3B0aW9ucyA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBzY3JvbGxhYmxlRWw6IEVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoc2Nyb2xsYWJsZSk7XHJcbiAgICBjb25zdCB0YXJnZXRFbDogRWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCh0YXJnZXQsIHNjcm9sbGFibGVFbCk7XHJcblxyXG4gICAgaWYgKHRhcmdldEVsICYmIHNjcm9sbGFibGVFbCkge1xyXG4gICAgICBjb25zdCBzY3JvbGxhYmxlUmVjdDogRE9NUmVjdCA9IHNjcm9sbGFibGVFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgY29uc3QgdGFyZ2V0UmVjdDogRE9NUmVjdCA9IHRhcmdldEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgICAgY29uc3Qgb3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zID0ge1xyXG4gICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXHJcbiAgICAgICAgbGVmdDogdGFyZ2V0UmVjdC5sZWZ0ICsgc2Nyb2xsYWJsZUVsLnNjcm9sbExlZnQgLSBzY3JvbGxhYmxlUmVjdC5sZWZ0ICsgKGN1c3RvbU9wdGlvbnMubGVmdCB8fCAwKSxcclxuICAgICAgICB0b3A6IHRhcmdldFJlY3QudG9wICsgc2Nyb2xsYWJsZUVsLnNjcm9sbFRvcCAtIHNjcm9sbGFibGVSZWN0LnRvcCArIChjdXN0b21PcHRpb25zLnRvcCB8fCAwKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG8oc2Nyb2xsYWJsZUVsLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfVxyXG59XHJcbiJdfQ==